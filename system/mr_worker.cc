#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"
#include "chfs_client.h"

using namespace std;

chfs_client *chfs_c;
extent_client *ec;



bool isLetter(char ch){
    return ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'));
}


//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.

	vector<KeyVal> v;
    string s1 = " ";
    string s2;
    int start = 0;
    int end = content.length();
    for(auto i=0; i<content.length();++i) {
          if(!isLetter(content[i]) || i == content.length()-1) {
                if(s2.length() > 0) {
                    KeyVal k;
                    k.key = s2;
                    k.val = "1";
                    v.push_back(k);
                }
                s2.clear();
           } 
           else if(isLetter(content[i])) {
               s2 = s2 + content[i];
           }  

    }
    return v;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.

	int sum = 0;
    for (auto &_value: values){
        sum += atoi(_value.data());
    }
    return to_string(sum);

}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);
	void doWork();

private:
	void doMap(mr_protocol::AskTaskResponse a);
	void doReduce(mr_protocol::AskTaskResponse a);
	void doSubmit(mr_tasktype taskType, int index,vector<KeyVal> &v, bool &b);
	mutex mtx;
	int id;
    bool doing_work = false;
	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(mr_protocol::AskTaskResponse a) {
	// Lab4: Your code goes here.
	string buf;
	ec->get(a.inum,buf);
	string filname;
	vector<KeyVal> k = Map(filname,buf);
	bool b = true;
	doSubmit(mr_tasktype::MAP,a.index,k,b);
}

void Worker::doReduce(mr_protocol::AskTaskResponse a) {
	// Lab4: Your code goes here.
	string buf;
	ec->get(a.inum,buf);
	//chfs_c->print(to_string(buf.length()) + "reduce length" + to_string(a.inum));
	vector<KeyVal> intermediate;
	string s1;
	string s2;
	bool key_add = false;
	for(int i=0; i<buf.length();i++) {
		if(buf[i] == '\n') {
           KeyVal k;
		   k.key = s1;
		   k.val = s2;
		   intermediate.push_back(k);
		   s1.clear();
		   s2.clear();
		   key_add = false;
		} else if(buf[i] == ' ') {
			key_add = true;
		} else {
			if(key_add) {
				s2 = s2 + buf[i];
			} else {
				s1 = s1 + buf[i];
			}
		}
	}
	//chfs_c->print(to_string(intermediate.size()) + "iiiiiiiiiiiiiii" + to_string(a.inum));
	sort(intermediate.begin(), intermediate.end(),
         [](KeyVal const & a, KeyVal const & b) {
             return a.key < b.key;
         });
    string content;
   vector<KeyVal> output;
	 for (unsigned int i = 0; i < intermediate.size();) {
        unsigned int j = i + 1;
        for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;)
            j++;
        vector < string > values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(intermediate[k].val);
        }
        string count = Reduce(intermediate[i].key, values);
		content += intermediate[i].key + ' ' + count + '\n';
        KeyVal k;
		k.key = intermediate[i].key;
		k.val = count;
		//output.push_back(k);
        i = j;
    }
	//chfs_c->print(content);
	string filepath = basedir + "mr-out-" + to_string(a.index);
    ofstream outfile(filepath);
    outfile << content << endl;
    outfile.close();
	bool b = true;
	doSubmit(mr_tasktype::REDUCE,a.index,output,b);
}

void Worker::doSubmit(mr_tasktype taskType, int index,vector<KeyVal> &v, bool &b){
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType,index,v,b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	} else {
		this->doing_work = false;
	}
}


void Worker::doWork()
{
	for (;;) {

		//
		// Lab4: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		if(!this->doing_work) {
			mr_protocol::AskTaskResponse a;
			int ret = cl->call(mr_protocol::asktask,id,a);
			if (ret == mr_protocol::OK){
				this->doing_work = true;
				//chfs_c->print("askResponse" + to_string(a.index));
				// chfs_c->print(to_string(res.taskType));
				if(a.taskType == mr_tasktype::MAP) {
					doMap(a);
				}  else if(a.taskType == mr_tasktype::REDUCE) {
                    doReduce(a);
				}
			}
		}
		sleep(1);
	}
}

int main(int argc, char **argv)
{
	// if (argc != 3) {
	// 	fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
	// 	exit(1);
	// }

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	std::string extent_port = argv[2];
	ec = new extent_client(extent_port);
	Worker w(argv[1], argv[3], mf, rf);
	w.doWork();
	return 0;
}
